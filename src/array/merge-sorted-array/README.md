# 88. 合并两个有序数组 (Merge Sorted Array)

## 1. 题目描述

给你两个按**非递减顺序**排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你**合并** `nums2` 到 `nums1` 中，使合并后的数组同样按**非递减顺序**排列。

**注意**：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 0 ，应忽略。`nums2` 的长度为 `n`。

**示例:**

```
输入: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出: [1,2,2,3,5,6]
解释: 我们需要合并 [1,2,3] 和 [2,5,6]。
合并结果是 [1,2,2,3,5,6]，其中斜体加粗的元素来自 nums1。
```

## 2. 代码实现

```typescript
/**
 * 解法一：合并后排序
 */
export function mergeSortedArraySort(nums1: number[], m: number, nums2: number[], n: number): void {
  for (let i = 0; i < n; i++) {
    nums1[m + i] = nums2[i]!;
  }
  nums1.sort((a, b) => a - b);
}

/**
 * 解法二：双指针（从前往后）
 */
export function mergeSortedArrayTwoPointers(nums1: number[], m: number, nums2: number[], n: number): void {
  const nums1Copy = nums1.slice(0, m);
  let p1 = 0;
  let p2 = 0;
  let p = 0;
  
  while (p1 < m && p2 < n) {
    if (nums1Copy[p1]! <= nums2[p2]!) {
      nums1[p++] = nums1Copy[p1++]!;
    } else {
      nums1[p++] = nums2[p2++]!;
    }
  }
  
  while (p1 < m) {
    nums1[p++] = nums1Copy[p1++]!;
  }
  
  while (p2 < n) {
    nums1[p++] = nums2[p2++]!;
  }
}

/**
 * 解法三：双指针（从后往前）
 */
export function mergeSortedArrayReverse(nums1: number[], m: number, nums2: number[], n: number): void {
  let p1 = m - 1;
  let p2 = n - 1;
  let p = m + n - 1;
  
  while (p1 >= 0 && p2 >= 0) {
    if (nums1[p1]! > nums2[p2]!) {
      nums1[p--] = nums1[p1--]!;
    } else {
      nums1[p--] = nums2[p2--]!;
    }
  }
  
  while (p2 >= 0) {
    nums1[p--] = nums2[p2--]!;
  }
}
```

## 3. 方案对比

| 解法 | 优点 | 缺点 |
| --- | --- | --- |
| **合并后排序** | 实现最简单，代码行数最少。 | 时间复杂度较高，不是最优解。 |
| **双指针（从前往后）** | 时间复杂度为线性，性能较好。 | 需要 O(m) 的额外空间来存储 `nums1` 的副本。 |
| **双指针（从后往前）** | 时间复杂度和空间复杂度都达到最优。 | 逻辑稍复杂，需要处理好指针的移动。 |

## 4. 复杂度分析

- **合并后排序**:
  - **时间复杂度**: O((m+n)log(m+n))。主要是排序操作的开销。
  - **空间复杂度**: O(1) 或 O(log(m+n))。取决于 `sort` 方法的底层实现，通常是原地排序或需要少量栈空间。

- **双指针（从前往后）**:
  - **时间复杂度**: O(m+n)。每个元素只被访问一次。
  - **空间复杂度**: O(m)。需要一个额外的数组来复制 `nums1` 的前 `m` 个元素。

- **双指针（从后往前）**:
  - **时间复杂度**: O(m+n)。每个元素只被访问一次。
  - **空间复杂度**: O(1)。在 `nums1` 数组上原地修改，不需要额外空间。

## 5. 优化建议

**双指针（从后往前）** 的解法是此问题的最优解。它在 `nums1` 数组的末尾（即预留的0空间）开始填充，巧妙地避免了从前往后合并时需要移动 `nums1` 元素的覆盖问题，从而实现了 O(1) 的空间复杂度。

## 6. 思想讲解

### 合并后排序

最直观的方法。首先将 `nums2` 的所有元素复制到 `nums1` 的末尾，然后对整个 `nums1` 数组进行排序。虽然简单，但没有利用数组已经部分有序的特性，导致性能不佳。

### 双指针（从前往后）

这个方法利用了两个数组已经有序的特性。但是，如果直接在 `nums1` 上操作，当 `nums2` 的元素需要插入到 `nums1` 的前面时，会导致 `nums1` 后续元素的移动，非常低效。

为了解决这个问题，我们先创建一个 `nums1` 的副本 `nums1Copy`。然后使用三个指针：`p1` 指向 `nums1Copy` 的头部，`p2` 指向 `nums2` 的头部，`p` 指向 `nums1` 的头部。比较 `nums1Copy[p1]` 和 `nums2[p2]` 的大小，将较小的元素放入 `nums1[p]`，并移动相应的指针。重复此过程直到其中一个数组遍历完毕，再将另一个数组剩余的元素复制到 `nums1` 的末尾。

### 双指针（从后往前）

这是最优解法。该方法认识到 `nums1` 的后半部分是空的，可以作为填充区域。因此，我们可以从后往前填充 `nums1`。

使用三个指针：
- `p1` 指向 `nums1` 有效元素的末尾（`m-1`）。
- `p2` 指向 `nums2` 的末尾（`n-1`）。
- `p` 指向 `nums1` 的最末尾（`m+n-1`）。

在循环中，比较 `nums1[p1]` 和 `nums2[p2]` 的大小，将**较大**的元素放入 `nums1[p]`，然后将对应的指针（`p1` 或 `p2`）和 `p` 向前移动。这样可以保证每次放入的都是当前未排序部分的最大元素，且不会覆盖 `nums1` 中尚未比较的元素。

如果 `nums2` 还有剩余元素（`p2 >= 0`），说明它们都比 `nums1` 的所有元素小，直接将它们复制到 `nums1` 的开头即可。