# 141. 环形链表
## Linked List Cycle

## 1. 题目描述

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

#### 示例 1：
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 示例 2：
```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

#### 示例 3：
```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

#### 提示：
- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

## 2. 思想讲解

### 方法一：哈希表
最直观的思路是记录下所有访问过的节点。在遍历链表时，每访问一个新节点，就检查它是否已经存在于记录中。如果存在，说明遇到了重复的节点，即链表有环。

1.  **初始化**:
    *   创建一个哈希集合 `set`，用于存储已访问的节点。
2.  **遍历**:
    *   从 `head` 开始遍历链表。
    *   对于每个节点，检查它是否在 `set` 中。
    *   如果在，返回 `true`。
    *   如果不在，将其加入 `set`，然后继续遍历下一个节点。
3.  **返回**:
    *   如果遍历完成（即到达 `null`），说明没有环，返回 `false`。

### 方法二：快慢指针（Floyd's Tortoise and Hare）
这是一个非常巧妙的算法，也称为“龟兔赛跑”算法。它使用两个指针，一个慢（`slow`）一个快（`fast`）。

1.  **初始化**:
    *   `slow` 指针和 `fast` 指针都从 `head` 开始。
2.  **移动**:
    *   `slow` 每次移动一步。
    *   `fast` 每次移动两步。
3.  **判断**:
    *   如果链表中没有环，`fast` 指针或 `fast.next` 会首先到达 `null`。
    *   如果链表中有环，`fast` 指针最终会从后面追上 `slow` 指针，它们会在环中的某个节点相遇。
4.  **返回**:
    *   如果相遇，返回 `true`。
    *   如果 `fast` 或 `fast.next` 变为 `null`，返回 `false`。

## 3. 代码实现

### 方法一：哈希表
```typescript
function hasCycle(head: ListNode | null): boolean {
    const set = new Set<ListNode>();
    while (head) {
        if (set.has(head)) {
            return true;
        }
        set.add(head);
        head = head.next;
    }
    return false;
}
```

### 方法二：快慢指针
```typescript
function hasCyclePointer(head: ListNode | null): boolean {
    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow!.next;
        fast = fast.next.next;
        if (slow === fast) {
            return true;
        }
    }

    return false;
}
```

## 4. 复杂度分析

### 方法一：哈希表
*   **时间复杂度**: O(n)，其中 n 是链表的节点数。最坏情况下，我们需要遍历整个链表。
*   **空间复杂度**: O(n)，需要一个哈希表来存储所有节点。

### 方法二：快慢指针
*   **时间复杂度**: O(n)。在有环的情况下，快指针在环内追上慢指针的步数不会超过环的长度。在无环的情况下，快指针会先到达终点。
*   **空间复杂度**: O(1)，只使用了两个指针，是常数级别的空间。

## 5. 方案对比

| 特性 | 哈希表 | 快慢指针 |
| :--- | :--- | :--- |
| **空间效率** | O(n)，占用较多内存 | O(1)，非常高效 |
| **实现复杂度** | 简单直观 | 稍微抽象，但很经典 |
| **数据修改** | 不修改原链表 | 不修改原链表 |
| **适用场景** | 简单快速实现 | 对空间有严格要求时，是首选方案 |

## 6. 优化建议

快慢指针法在空间和时间上都已经非常高效，是解决此问题的最优解法之一。对于不允许修改链表且要求 O(1) 空间复杂度的场景，这是标准答案。因此，没有太多进一步的优化空间。