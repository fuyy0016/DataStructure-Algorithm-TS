# 206. 反转链表
## Reverse Linked List

## 1. 题目描述

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

#### 示例 1：
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

#### 示例 2：
```
输入：head = [1,2]
输出：[2,1]
```

#### 示例 3：
```
输入：head = []
输出：[]
```

#### 提示：
- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

## 2. 思想讲解

### 方法一：迭代（双指针）
反转链表的核心思想是在遍历链表时，将当前节点的 `next` 指针指向其前一个节点。由于是单向链表，我们无法直接获取前一个节点，因此需要一个额外的指针 `pre` 来保存它。

1.  **初始化**:
    *   `pre`: 指向 `null`，它将成为新链表的尾部。
    *   `cur`: 指向 `head`，表示当前正在处理的节点。
2.  **遍历**:
    *   在 `cur` 不为 `null` 的条件下循环。
    *   用一个临时变量 `next` 保存 `cur.next`，防止断链。
    *   将 `cur.next` 指向 `pre`，完成反转。
    *   将 `pre` 更新为 `cur`。
    *   将 `cur` 更新为 `next`，处理下一个节点。
3.  **返回**:
    *   循环结束后，`cur` 为 `null`，`pre` 指向原链表的最后一个节点，即新链表的头节点。返回 `pre`。

### 方法二：递归
递归的解法更具声明性。其核心思想是：假设链表的其余部分（`head.next`）已经被成功反转，那么我们只需要处理头节点 `head` 和已反转部分的关系即可。

1.  **终止条件**:
    *   如果 `head` 为 `null` 或 `head.next` 为 `null`（即链表为空或只有一个节点），无需反转，直接返回 `head`。
2.  **递归步骤**:
    *   调用 `reverseListRecursive(head.next)`，获取已反转的子链表的头节点 `newHead`。
    *   此时，`head.next` 仍然指向原来的下一个节点（在反转后的子链表中是最后一个节点）。
    *   执行 `head.next.next = head`，将原 `head.next` 节点的 `next` 指针指向 `head`。
    *   执行 `head.next = null`，断开 `head` 与原后续节点的连接，避免形成环。
3.  **返回**:
    *   返回 `newHead`，它在整个递归过程中保持不变，始终是新链表的头。

## 3. 代码实现

### 方法一：迭代（双指针）
```typescript
function reverseList(head: ListNode | null): ListNode | null {
    let pre = null;
    let cur = head;
    while (cur) {
        // 暂存后继节点
        const next = cur.next;
        // 反转指针
        cur.next = pre;
        // 移动 pre 和 cur
        pre = cur;
        cur = next;
    }
    return pre;
}
```

### 方法二：递归
```typescript
function reverseListRecursive(head: ListNode | null): ListNode | null {
    // 终止条件
    if (head === null || head.next === null) {
        return head;
    }
    // 递归反转子链表
    const newHead = reverseListRecursive(head.next);
    // 将当前节点连接到反转后的子链表末尾
    head.next.next = head;
    head.next = null;
    // 返回新头节点
    return newHead;
}
```

## 4. 复杂度分析

### 方法一：迭代（双指针）
*   **时间复杂度**: O(n)，其中 n 是链表的长度。我们只需要遍历链表一次。
*   **空间复杂度**: O(1)，我们只使用了 `pre`、`cur` 和 `next` 三个额外指针，是常数级别的空间。

### 方法二：递归
*   **时间复杂度**: O(n)，其中 n 是链表的长度。每个节点都会被访问一次。
*   **空间复杂度**: O(n)，递归调用会产生 n 层的调用栈，最坏情况下（链表完全线性）空间复杂度为 O(n)。

## 5. 方案对比

| 特性 | 迭代（双指针） | 递归 |
| :--- | :--- | :--- |
| **直观性** | 过程清晰，易于理解指针的移动 | 概念简洁，但调用过程相对抽象 |
| **空间效率** | O(1)，非常高效 | O(n)，可能因栈溢出而出错 |
| **代码简洁性** | 代码稍长 | 代码更短 |
| **推荐场景** | 对空间有严格要求或处理超长链表时 | 追求代码简洁性，且链表长度可控 |

## 6. 优化建议

对于这个经典问题，迭代解法在空间复杂度上已经是最优的（O(1)）。递归解法虽然优雅，但存在栈溢出的风险。在实际工程中，迭代法通常是更稳健和高效的选择。该问题的解法已经非常成熟，没有太多额外的优化空间。